<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å…¨ç¶­åº¦å¤šäººéŒ„éŸ³å®¤ (MVP)</title>
    <style>
        :root {
            --bg-color: #1a1a1a;
            --panel-color: #2d2d2d;
            --text-color: #e0e0e0;
            --accent-color: #00d2ff;
            --danger-color: #ff4757;
            --success-color: #2ed573;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }
        /* ç™»å…¥é é¢ */
        #login-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            z-index: 10;
        }
        .card {
            background: var(--panel-color);
            padding: 2rem;
            border-radius: 12px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.3);
            text-align: center;
            width: 300px;
        }
        input {
            width: 100%;
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            border: 1px solid #444;
            background: #333;
            color: white;
            box-sizing: border-box;
        }
        button {
            padding: 10px 20px;
            border-radius: 4px;
            border: none;
            cursor: pointer;
            font-weight: bold;
            transition: 0.2s;
        }
        .btn-primary { background: var(--accent-color); color: #000; }
        .btn-primary:hover { background: #33e0ff; }
        .btn-danger { background: var(--danger-color); color: white; }
        .btn-record { background: var(--danger-color); color: white; width: 100%; margin-top: 10px; }
        
        /* ä¸»ä»‹é¢ */
        #app-screen {
            display: none; /* é è¨­éš±è— */
            flex: 1;
            flex-direction: column;
            padding: 20px;
            gap: 20px;
        }
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 10px;
            border-bottom: 1px solid #444;
        }
        
        /* ä½ˆå±€ */
        .main-container {
            display: flex;
            flex: 1;
            gap: 20px;
            overflow: hidden;
        }
        
        /* æˆå“¡åˆ—è¡¨ */
        .member-panel {
            flex: 1;
            background: var(--panel-color);
            border-radius: 8px;
            padding: 15px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .member-card {
            background: #3a3a3a;
            padding: 10px;
            border-radius: 6px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            border-left: 4px solid var(--accent-color);
        }
        .member-header {
            display: flex;
            justify-content: space-between;
            font-weight: bold;
        }
        .status-dot {
            height: 8px;
            width: 8px;
            background-color: #777;
            border-radius: 50%;
            display: inline-block;
            margin-right: 5px;
        }
        .connected { background-color: var(--success-color); }
        .controls-row {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 0.8rem;
        }
        input[type=range] { flex: 1; cursor: pointer; }

        /* éŸ³æ•ˆé¢æ¿ & éŒ„éŸ³ */
        .tools-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .soundboard {
            background: var(--panel-color);
            padding: 15px;
            border-radius: 8px;
        }
        .sb-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-top: 10px;
        }
        .sb-btn {
            background: #444;
            color: #fff;
            padding: 15px;
            font-size: 0.9rem;
        }
        .sb-btn:active { background: var(--accent-color); color: #000; transform: scale(0.95); }
        
        .recorder-panel {
            background: var(--panel-color);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }
        .rec-status {
            font-size: 1.5rem;
            font-family: monospace;
            color: var(--danger-color);
            margin: 10px 0;
        }
        .toggle-group {
            display: flex;
            align-items: center;
            gap: 10px;
            background: #333;
            padding: 5px 10px;
            border-radius: 20px;
            font-size: 0.8rem;
            width: fit-content;
            margin-bottom: 10px;
        }

        /* æç¤º */
        .warning {
            color: #ff9f43;
            font-size: 0.8rem;
            margin-top: 5px;
        }
        
        /* éš±è—çš„ Audio å…ƒç´  */
        audio { display: none; }
    </style>
</head>
<body>

    <!-- ç™»å…¥ç•«é¢ -->
    <div id="login-screen">
        <div class="card">
            <h2>é€²å…¥æ„è­˜éŒ„éŸ³å®¤</h2>
            <input type="text" id="nickname" placeholder="è¼¸å…¥ä½ çš„ä»£è™Ÿ (Nickname)" maxlength="10">
            <input type="text" id="roomId" placeholder="æˆ¿è™Ÿ (Room ID)" value="room1">
            <button class="btn-primary" onclick="joinRoom()">å»ºç«‹ / åŠ å…¥æˆ¿é–“</button>
            <div class="warning">âš ï¸ å»ºè­°é…æˆ´è€³æ©Ÿä»¥é¿å…å›æˆ (Echo)</div>
        </div>
    </div>

    <!-- ä¸»ç¨‹å¼ç•«é¢ -->
    <div id="app-screen">
        <header>
            <div>
                <span id="display-room" style="font-weight:bold; color:var(--accent-color)">Room: ???</span>
                <span style="margin: 0 10px">|</span>
                <span id="display-nick">Me: ???</span>
            </div>
            <div id="connection-status" style="font-size:0.8rem; color:#888;">å°šæœªé€£ç·š</div>
        </header>

        <div class="main-container">
            <!-- å·¦å´ï¼šæˆå“¡åˆ—è¡¨ -->
            <div class="member-panel" id="member-list">
                <!-- å‹•æ…‹ç”Ÿæˆçš„æˆå“¡å¡ç‰‡ -->
            </div>

            <!-- å³å´ï¼šå·¥å…· (éŸ³æ•ˆ + éŒ„éŸ³) -->
            <div class="tools-panel">
                
                <!-- éŸ³æ•ˆæ¿ -->
                <div class="soundboard">
                    <div style="display:flex; justify-content:space-between; align-items:center;">
                        <h3>Soundboard</h3>
                        <div class="toggle-group">
                            <label><input type="radio" name="sb-mode" value="local" checked> ç§å¯†è©¦è½</label>
                            <label><input type="radio" name="sb-mode" value="broadcast"> å»£æ’­å…¨å ´</label>
                        </div>
                    </div>
                    <div>
                        <label>éŸ³æ•ˆéŸ³é‡: <span id="sb-vol-val">80%</span></label>
                        <input type="range" id="sb-volume" min="0" max="150" value="80">
                    </div>
                    <div class="sb-grid">
                        <button class="sb-btn" onclick="playEffect('applause')">ğŸ‘ æŒè²</button>
                        <button class="sb-btn" onclick="playEffect('laugh')">ğŸ˜‚ ç¬‘è²</button>
                        <button class="sb-btn" onclick="playEffect('drum')">ğŸ¥ é¼“è²</button>
                        <button class="sb-btn" onclick="playEffect('beep')">ğŸ¤– Beep</button>
                        <button class="sb-btn" onclick="playEffect('boom')">ğŸ’¥ çˆ†ç‚¸</button>
                        <button class="sb-btn" onclick="playEffect('whoosh')">ğŸ’¨ å’»~</button>
                    </div>
                </div>

                <!-- éŒ„éŸ³å€ -->
                <div class="recorder-panel">
                    <h3>æ··éŸ³éŒ„è£½</h3>
                    <div style="font-size: 0.8rem; color:#aaa;">éŒ„è£½ç¯„åœï¼šä½ çš„éº¥å…‹é¢¨ + éšŠå‹è²éŸ³ + éŸ³æ•ˆ</div>
                    <div id="rec-timer" class="rec-status">00:00</div>
                    <button id="btn-record-toggle" class="btn-record" onclick="toggleRecording()">é–‹å§‹éŒ„éŸ³</button>
                    <div id="download-area" style="margin-top:10px;"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- è…³æœ¬é‚è¼¯ -->
    <script>
        // ================= çµ„æ…‹èˆ‡å…¨åŸŸè®Šæ•¸ =================
        // è‡ªå‹•åµæ¸¬ç›®å‰ç€è¦½å™¨çš„ç¶²å€èˆ‡ Port (ä¾‹å¦‚ localhost:3001)
        const SIGNALING_URL = 'ws://' + window.location.host; 
        
        let ws;
        let myId = null;
        let myNickname = "";
        let roomId = "";
        
        // Web Audio Context
        let audioCtx;
        let micSourceNode;      // éº¥å…‹é¢¨åŸå§‹æº
        let micGainNode;        // éº¥å…‹é¢¨å¢ç›Š
        let soundboardGainNode; // éŸ³æ•ˆç¸½å¢ç›Š
        
        // è·¯ç”±ç¯€é» (Destinations)
        let recordDestNode;     // çµ¦éŒ„éŸ³ç”¨çš„ Destination (æ··åˆå…¨éƒ¨)
        let peerDestNode;       // çµ¦ WebRTC å‚³è¼¸ç”¨çš„ Destination (éº¥å…‹é¢¨ + å»£æ’­éŸ³æ•ˆ)
        
        // ç‹€æ…‹
        const peers = {}; // { peerId: { conn: RTCPeerConnection, audioElem: HTMLAudioElement, gainNode: GainNode, ... } }
        let localStream = null;
        let mediaRecorder = null;
        let recordedChunks = [];
        let isRecording = false;
        let recordingStartTime = 0;
        let recordInterval = null;

        // éŸ³æ•ˆåˆæˆåƒæ•¸ (ç°¡å–®çš„ Web Audio Oscillator æ¨¡æ“¬)
        const sfxConfig = {
            'applause': { type: 'noise', duration: 1.5, decay: true }, 
            'laugh': { type: 'sawtooth', freq: [400, 600, 400, 600], duration: 0.5 },
            'drum': { type: 'sine', freq: 100, endFreq: 50, duration: 0.1 },
            'beep': { type: 'square', freq: 880, duration: 0.1 },
            'boom': { type: 'sawtooth', freq: 100, endFreq: 10, duration: 0.8 },
            'whoosh': { type: 'noise', duration: 0.5, fade: true }
        };

        // ICE Server (ä½¿ç”¨ Google å…¬ç”¨ STUN)
        const rtcConfig = {
            iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
        };

        // ================= 1. åˆå§‹åŒ–èˆ‡éŸ³è¨Šè·¯ç”±å»ºç½® =================
        
        async function joinRoom() {
            const nickInput = document.getElementById('nickname');
            const roomInput = document.getElementById('roomId');
            
            if (!nickInput.value || !roomInput.value) {
                alert("è«‹è¼¸å…¥ä»£è™Ÿèˆ‡æˆ¿è™Ÿ");
                return;
            }

            myNickname = nickInput.value;
            roomId = roomInput.value;

            try {
                // 1. å•Ÿå‹• AudioContext (å¿…é ˆåœ¨ä½¿ç”¨è€…æ“ä½œå¾Œ)
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                
                // 2. ç²å–éº¥å…‹é¢¨æ¬Šé™
                localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });

                // 3. å»ºç«‹éŸ³è¨Šè·¯ç”±åœ– (Audio Graph)
                setupAudioGraph();

                // 4. åˆ‡æ› UI
                document.getElementById('login-screen').style.display = 'none';
                document.getElementById('app-screen').style.display = 'flex';
                document.getElementById('display-room').textContent = `Room: ${roomId}`;
                document.getElementById('display-nick').textContent = `Me: ${myNickname}`;

                // 5. é€£ç·š WebSocket
                connectSignaling();

                // 6. é¡¯ç¤ºè‡ªå·±
                updateMemberList();

            } catch (err) {
                console.error(err);
                alert("ç„¡æ³•å­˜å–éº¥å…‹é¢¨æˆ–ç™¼ç”ŸéŒ¯èª¤: " + err.message);
            }
        }

        // æ ¸å¿ƒï¼šéŸ³è¨Šè·¯ç”±è¨­å®š
        function setupAudioGraph() {
            // A. å»ºç«‹ç¯€é»
            micSourceNode = audioCtx.createMediaStreamSource(localStream);
            micGainNode = audioCtx.createGain(); // æ§åˆ¶è‡ªå·±éº¥å…‹é¢¨éŸ³é‡ (ä¸»è¦ç”¨æ–¼ Mute)
            
            soundboardGainNode = audioCtx.createGain();
            soundboardGainNode.gain.value = 0.8;

            // B. å»ºç«‹ Destinations
            // ç”¨æ–¼éŒ„éŸ³ (éŒ„ä¸‹: è‡ªå·±çš„éº¥ + åˆ¥äººè²éŸ³ + éŸ³æ•ˆ)
            recordDestNode = audioCtx.createMediaStreamDestination();
            
            // ç”¨æ–¼ç™¼é€çµ¦ Peer (ç™¼é€: è‡ªå·±çš„éº¥ + å»£æ’­çš„éŸ³æ•ˆ) *ä¸è¦åŒ…å«åˆ¥äººçš„è²éŸ³ä»¥å…å›æˆ*
            peerDestNode = audioCtx.createMediaStreamDestination();

            // C. é€£æ¥ç·šè·¯
            
            // 1. éº¥å…‹é¢¨ -> Peer Destination (å‚³çµ¦åˆ¥äºº)
            micSourceNode.connect(micGainNode);
            micGainNode.connect(peerDestNode); 
            
            // 2. éº¥å…‹é¢¨ -> Record Destination (éŒ„é€²å»)
            micGainNode.connect(recordDestNode);
            
            // *æ³¨æ„ï¼šéº¥å…‹é¢¨ä¸è¦é€£åˆ° ctx.destination (é¿å…è‡ªå·±è½åˆ°è‡ªå·±å›éŸ³)*

            // 3. éŸ³æ•ˆ -> æ ¹æ“šæ¨¡å¼åˆ‡æ›
            // éŸ³æ•ˆç¸½æ˜¯é€£åˆ°éŒ„éŸ³ç«¯èˆ‡è‡ªå·±è€³æ©Ÿ(destination)
            soundboardGainNode.connect(audioCtx.destination);
            soundboardGainNode.connect(recordDestNode);
            // æ˜¯å¦é€£åˆ° peerDestNode (å»£æ’­) ç”±æ’­æ”¾æ™‚çš„ toggle æ±ºå®šï¼Œé€™è£¡å…ˆé ç•™ç·šè·¯
        }

        // ================= 2. WebSocket Signaling =================

        function connectSignaling() {
            ws = new WebSocket(SIGNALING_URL);

            ws.onopen = () => {
                document.getElementById('connection-status').textContent = "ä¼ºæœå™¨å·²é€£ç·š";
                // å‚³é€åŠ å…¥è¨Šæ¯
                sendSignal({ type: 'join', roomId: roomId, nickname: myNickname });
            };

            ws.onmessage = async (event) => {
                const data = JSON.parse(event.data);
                handleSignalingData(data);
            };

            ws.onclose = () => {
                document.getElementById('connection-status').textContent = "ä¼ºæœå™¨æ–·ç·š";
                document.getElementById('connection-status').style.color = "red";
            };
        }

        async function handleSignalingData(data) {
            switch (data.type) {
                case 'room-info':
                    // æ”¶åˆ°æˆ¿é–“å…§ç¾æœ‰æˆå“¡åˆ—è¡¨ï¼Œé–‹å§‹å°æ¯å€‹äººç™¼èµ·é€£ç·š (æˆ‘æ˜¯å¾Œä¾†è€…)
                    data.members.forEach(member => {
                        if (member.id !== myId) {
                            createPeerConnection(member.id, member.nickname, true); // true = initiator (Offerç«¯)
                        }
                    });
                    break;

                case 'user-joined':
                    // æœ‰æ–°äººåŠ å…¥ï¼Œé¡¯ç¤ºé€šçŸ¥ï¼Œç­‰å¾…å°æ–¹ç™¼ Offer
                    addSystemLog(`${data.nickname} åŠ å…¥äº†æˆ¿é–“`);
                    break;

                case 'user-left':
                    removePeer(data.id);
                    addSystemLog(`æˆå“¡å·²é›¢é–‹`);
                    break;

                case 'signal':
                    // WebRTC ä¿¡ä»¤äº¤æ› (Offer/Answer/ICE)
                    const peerId = data.from;
                    if (!peers[peerId]) {
                        // å¦‚æœæ˜¯è¢«å‹•æ¥æ”¶ Offerï¼Œå…ˆå»ºç«‹ PC
                        // é€™è£¡å‡è¨­ signal å¸¶æœ‰ nickname (è‹¥ç„¡å¯å¾ server å„ªåŒ–ï¼ŒMVP ç°¡åŒ–è™•ç†)
                        await createPeerConnection(peerId, "Unknown", false);
                    }
                    const pc = peers[peerId].conn;

                    if (data.desc) {
                        await pc.setRemoteDescription(new RTCSessionDescription(data.desc));
                        if (data.desc.type === 'offer') {
                            const answer = await pc.createAnswer();
                            await pc.setLocalDescription(answer);
                            sendSignal({ type: 'signal', to: peerId, desc: answer });
                        }
                    } else if (data.candidate) {
                        try {
                            await pc.addIceCandidate(new RTCIceCandidate(data.candidate));
                        } catch (e) { console.error("ICE Error", e); }
                    }
                    break;
                
                case 'welcome':
                    myId = data.id;
                    break;
            }
        }

        function sendSignal(msg) {
            ws.send(JSON.stringify(msg));
        }

        // ================= 3. WebRTC Peer Connection (Mesh) =================

        async function createPeerConnection(targetId, nickname, isInitiator) {
            if (peers[targetId]) return; // å·²å­˜åœ¨

            const pc = new RTCPeerConnection(rtcConfig);
            
            // å»ºç«‹ UI å¡ç‰‡
            addPeerUI(targetId, nickname);

            // A. æŠŠæˆ‘å€‘è™•ç†éçš„éŸ³è¨Šæµ (éº¥ + å»£æ’­éŸ³æ•ˆ) åŠ å…¥ PC
            // æ³¨æ„ï¼šé€™è£¡ä¸åŠ  localStreamï¼Œè€Œæ˜¯åŠ  peerDestNode.stream
            peerDestNode.stream.getTracks().forEach(track => pc.addTrack(track, peerDestNode.stream));

            // B. è™•ç†é ç«¯ä¸²æµ
            pc.ontrack = (event) => {
                const remoteStream = event.streams[0];
                handleRemoteStream(targetId, remoteStream);
            };

            // C. ICE Candidate è™•ç†
            pc.onicecandidate = (event) => {
                if (event.candidate) {
                    sendSignal({ type: 'signal', to: targetId, candidate: event.candidate });
                }
            };

            pc.onconnectionstatechange = () => {
                updatePeerStatusUI(targetId, pc.connectionState);
                if (pc.connectionState === 'disconnected' || pc.connectionState === 'failed') {
                    removePeer(targetId);
                }
            };

            // å„²å­˜åƒç…§
            peers[targetId] = { conn: pc, nickname: nickname };

            // D. å¦‚æœæ˜¯ç™¼èµ·è€…ï¼Œå»ºç«‹ Offer
            if (isInitiator) {
                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);
                sendSignal({ type: 'signal', to: targetId, desc: offer });
            }
        }

        // è™•ç†é ç«¯è²éŸ³ (è·¯ç”±åˆ°è€³æ©Ÿ + éŒ„éŸ³)
        function handleRemoteStream(peerId, stream) {
            // ä½¿ç”¨ Web Audio è™•ç†é ç«¯è²éŸ³ä»¥ä¾¿éŒ„è£½
            const remoteSource = audioCtx.createMediaStreamSource(stream);
            const remoteGain = audioCtx.createGain(); // é ç«¯éŸ³é‡æ§åˆ¶
            
            // 1. é€£åˆ°è€³æ©Ÿ (ç›£è½)
            remoteGain.connect(audioCtx.destination);
            
            // 2. é€£åˆ°éŒ„éŸ³ (éŒ„è£½)
            remoteGain.connect(recordDestNode);

            // å„²å­˜ GainNode ä»¥ä¾¿ UI æ§åˆ¶
            if (peers[peerId]) {
                peers[peerId].gainNode = remoteGain;
                remoteSource.connect(remoteGain);
            }
            
            // è®“ AudioContext ä¿æŒæ´»èº (æŸäº›ç€è¦½å™¨éœ€è¦)
            const audioElem = new Audio();
            audioElem.srcObject = stream;
            audioElem.play().catch(e => console.log("Auto-play prevented", e));
        }

        function removePeer(id) {
            if (peers[id]) {
                peers[id].conn.close();
                // ç§»é™¤ UI
                const el = document.getElementById(`peer-${id}`);
                if (el) el.remove();
                delete peers[id];
            }
        }

        // ================= 4. UI é‚è¼¯èˆ‡ DOM æ“ä½œ =================

        function addPeerUI(id, nickname) {
            const container = document.getElementById('member-list');
            const div = document.createElement('div');
            div.id = `peer-${id}`;
            div.className = 'member-card';
            div.innerHTML = `
                <div class="member-header">
                    <span>${nickname}</span>
                    <div><span class="status-dot connecting" id="status-${id}"></span></div>
                </div>
                <div class="controls-row">
                    <span>éŸ³é‡</span>
                    <input type="range" min="0" max="150" value="100" oninput="setPeerVolume('${id}', this.value)">
                </div>
                <div style="text-align:right; font-size:0.7rem; color:#666;">ID: ${id.substr(0,4)}</div>
            `;
            container.appendChild(div);
        }

        function updatePeerStatusUI(id, state) {
            const dot = document.getElementById(`status-${id}`);
            if (dot) {
                dot.className = `status-dot ${state === 'connected' ? 'connected' : ''}`;
            }
        }

        function setPeerVolume(id, val) {
            if (peers[id] && peers[id].gainNode) {
                peers[id].gainNode.gain.value = val / 100;
            }
        }

        // é¡¯ç¤ºè‡ªå·± (éœæ…‹)
        function updateMemberList() {
            // å¯ä»¥åœ¨ member list æœ€ä¸Šé¢åŠ è‡ªå·±ï¼ŒMVP ç•¥é
        }
        
        function addSystemLog(msg) {
            console.log(`[System] ${msg}`);
        }

        // ================= 5. éŸ³æ•ˆæ¿èˆ‡åˆæˆ (Web Audio) =================

        // éŸ³é‡ç›£è½
        document.getElementById('sb-volume').addEventListener('input', (e) => {
            const val = e.target.value;
            document.getElementById('sb-vol-val').textContent = val + '%';
            if (soundboardGainNode) {
                soundboardGainNode.gain.value = val / 100;
            }
        });

        function playEffect(name) {
            if (!audioCtx) return;

            const mode = document.querySelector('input[name="sb-mode"]:checked').value;
            const config = sfxConfig[name];
            
            // å»ºç«‹æŒ¯ç›ªå™¨èˆ‡å™ªè²æº
            const t = audioCtx.currentTime;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            
            // ç·šè·¯ï¼šOsc -> Gain -> MasterSBGain
            gain.connect(soundboardGainNode);

            // ç‰¹æ®Šè·¯ç”±é‚è¼¯ï¼š
            // è‹¥ç‚º broadcastï¼Œæˆ‘å€‘éœ€è¦æš«æ™‚æŠŠ soundboardGainNode é€£æ¥åˆ° peerDestNode
            // ç‚ºäº†é¿å…æ¯æ¬¡éƒ½ disconnectï¼Œæˆ‘å€‘ä½¿ç”¨ä¸€å€‹é–‹é—œ Gain
            if (mode === 'broadcast') {
                // åŸæœ¬ soundboardGainNode æ²’æœ‰é€£åˆ° peerDestNode (é è¨­)ï¼Œé€™è£¡å‹•æ…‹é€£ä¸€ä¸‹ä¸å¤ªå¥½ç®¡ç†
                // æ”¹é€²ï¼šä½¿ç”¨ä¸€å€‹å°ˆé–€çš„ switchGain
                // é€™è£¡ç°¡åŒ–ï¼šå¦‚æœ broadcastï¼Œå°±è®“è²éŸ³é€²å…¥ peerDestNodeï¼Œå¦å‰‡åªé€² local & record
                const broadcastSwitch = audioCtx.createGain();
                broadcastSwitch.gain.value = (mode === 'broadcast') ? 1 : 0;
                
                // é€™è£¡ç¨å¾®è¤‡é›œï¼Œæˆ‘å€‘ç›´æ¥è®“ soundboardGainNode é€£æ¥åˆ° peerDestNode
                // ä½†ç‚ºäº†å¯¦ç¾ã€Œåªè‡ªå·±è½ã€ï¼Œæˆ‘å€‘åœ¨æŒ‰ä¸‹æŒ‰éˆ•æ™‚ï¼Œå»ºç«‹è‡¨æ™‚è·¯å¾‘
            }

            // --- ç°¡å–®çš„éŸ³æ•ˆåˆæˆå¯¦ä½œ ---
            // ç‚ºäº† MVP ç°¡å–®åŒ–ï¼Œæˆ‘å€‘ç›´æ¥ç”Ÿæˆè²éŸ³åˆ° soundboardGainNode
            // ç„¶å¾Œæ§åˆ¶ soundboardGainNode -> peerDestNode çš„é€£ç·šï¼Ÿ
            // ä¸ï¼Œå¤ªæ…¢ã€‚æˆ‘å€‘ç›´æ¥å‡è¨­ï¼š
            // 1. soundboardGainNode æ°¸ä¹…é€£åˆ° destination & recordDestNode
            // 2. å¦‚æœæ˜¯ broadcastï¼Œæˆ‘å€‘ *é¡å¤–* å»ºç«‹ä¸€å€‹é€£ç·šåˆ° peerDestNode
            
            const sourceConnect = () => {
                gain.connect(soundboardGainNode);
                if (mode === 'broadcast') {
                   gain.connect(peerDestNode); // è®“é ç«¯ä¹Ÿè½åˆ°é€™å€‹ source
                }
            };
            
            sourceConnect();

            if (config.type === 'noise') {
                // ç™½å™ªéŸ³å¯¦ä½œ (Applause / Whoosh)
                const bufferSize = audioCtx.sampleRate * config.duration;
                const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                const noise = audioCtx.createBufferSource();
                noise.buffer = buffer;
                if (config.decay) {
                    gain.gain.setValueAtTime(1, t);
                    gain.gain.exponentialRampToValueAtTime(0.01, t + config.duration);
                }
                if (config.fade) { // Whoosh
                    gain.gain.setValueAtTime(0, t);
                    gain.gain.linearRampToValueAtTime(1, t + config.duration/2);
                    gain.gain.linearRampToValueAtTime(0, t + config.duration);
                }
                noise.connect(gain);
                noise.start();
            } else {
                // æŒ¯ç›ªå™¨å¯¦ä½œ
                osc.type = config.type;
                if (config.freq) {
                    if (Array.isArray(config.freq)) {
                        // Laugh (wobble)
                        osc.frequency.setValueAtTime(config.freq[0], t);
                        osc.frequency.linearRampToValueAtTime(config.freq[1], t + 0.1);
                        osc.frequency.linearRampToValueAtTime(config.freq[2], t + 0.2);
                        osc.frequency.linearRampToValueAtTime(config.freq[3], t + 0.3);
                    } else {
                        osc.frequency.setValueAtTime(config.freq, t);
                        if (config.endFreq) {
                            osc.frequency.exponentialRampToValueAtTime(config.endFreq, t + config.duration);
                        }
                    }
                }
                gain.gain.setValueAtTime(1, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + config.duration);
                
                osc.connect(gain);
                osc.start();
                osc.stop(t + config.duration);
            }
        }

        // ================= 6. éŒ„éŸ³åŠŸèƒ½ (MediaRecorder) =================

        function toggleRecording() {
            const btn = document.getElementById('btn-record-toggle');
            
            if (!isRecording) {
                // é–‹å§‹éŒ„éŸ³
                // ä½¿ç”¨ recordDestNode.stream (åŒ…å« Mic + Remote + Soundboard)
                const mixedStream = recordDestNode.stream;
                
                try {
                    mediaRecorder = new MediaRecorder(mixedStream, { mimeType: 'audio/webm' });
                } catch (e) {
                    alert("ç€è¦½å™¨ä¸æ”¯æ´ WebM éŒ„è£½ï¼Œè«‹ä½¿ç”¨ Chrome/Firefox");
                    return;
                }

                recordedChunks = [];
                mediaRecorder.ondataavailable = (e) => {
                    if (e.data.size > 0) recordedChunks.push(e.data);
                };

                mediaRecorder.onstop = exportRecording;

                mediaRecorder.start();
                isRecording = true;
                btn.textContent = "åœæ­¢éŒ„éŸ³";
                btn.style.background = "#333";
                
                // è¨ˆæ™‚å™¨
                recordingStartTime = Date.now();
                recordInterval = setInterval(() => {
                    const diff = Math.floor((Date.now() - recordingStartTime) / 1000);
                    const m = Math.floor(diff / 60).toString().padStart(2, '0');
                    const s = (diff % 60).toString().padStart(2, '0');
                    document.getElementById('rec-timer').textContent = `${m}:${s}`;
                }, 1000);

            } else {
                // åœæ­¢éŒ„éŸ³
                mediaRecorder.stop();
                isRecording = false;
                btn.textContent = "é–‹å§‹éŒ„éŸ³";
                btn.style.background = "var(--danger-color)";
                clearInterval(recordInterval);
            }
        }

        function exportRecording() {
            const blob = new Blob(recordedChunks, { type: 'audio/webm' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            
            a.style.display = 'block';
            a.href = url;
            a.download = `recording-${timestamp}.webm`;
            a.textContent = `ä¸‹è¼‰éŒ„éŸ³ (${(blob.size/1024/1024).toFixed(2)} MB)`;
            a.className = 'btn-primary';
            a.style.marginTop = '10px';
            a.style.textDecoration = 'none';
            a.style.lineHeight = '40px';
            
            const area = document.getElementById('download-area');
            area.innerHTML = '';
            area.appendChild(a);
        }

    </script>
</body>
</html>
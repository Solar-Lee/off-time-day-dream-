<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å…¨ç¶­åº¦å¤šäººéŒ„éŸ³å®¤ (é›²ç«¯ç‰ˆ)</title>
    <style>
        :root {
            --bg-color: #1a1a1a;
            --panel-color: #2d2d2d;
            --text-color: #e0e0e0;
            --accent-color: #00d2ff;
            --danger-color: #ff4757;
            --success-color: #2ed573;
            --warn-color: #ff9f43;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }
        /* ç™»å…¥é é¢ */
        #login-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            z-index: 10;
        }
        .card {
            background: var(--panel-color);
            padding: 2rem;
            border-radius: 12px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.3);
            text-align: center;
            width: 300px;
        }
        input {
            width: 100%;
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            border: 1px solid #444;
            background: #333;
            color: white;
            box-sizing: border-box;
        }
        button {
            padding: 10px 20px;
            border-radius: 4px;
            border: none;
            cursor: pointer;
            font-weight: bold;
            transition: 0.2s;
        }
        .btn-primary { background: var(--accent-color); color: #000; }
        .btn-primary:hover { background: #33e0ff; }
        .btn-danger { background: var(--danger-color); color: white; }
        .btn-record { background: var(--danger-color); color: white; width: 100%; margin-top: 10px; }
        
        /* ä¸»ä»‹é¢ */
        #app-screen {
            display: none; /* é è¨­éš±è— */
            flex: 1;
            flex-direction: column;
            padding: 20px;
            gap: 20px;
        }
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 10px;
            border-bottom: 1px solid #444;
        }
        
        /* ä½ˆå±€ */
        .main-container {
            display: flex;
            flex: 1;
            gap: 20px;
            overflow: hidden;
        }
        
        /* æˆå“¡åˆ—è¡¨ */
        .member-panel {
            flex: 1;
            background: var(--panel-color);
            border-radius: 8px;
            padding: 15px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .member-card {
            background: #3a3a3a;
            padding: 10px;
            border-radius: 6px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            border-left: 4px solid var(--accent-color);
        }
        .member-header {
            display: flex;
            justify-content: space-between;
            font-weight: bold;
        }
        .status-dot {
            height: 8px;
            width: 8px;
            background-color: #777;
            border-radius: 50%;
            display: inline-block;
            margin-right: 5px;
        }
        .connected { background-color: var(--success-color); }
        .controls-row {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 0.8rem;
        }
        input[type=range] { flex: 1; cursor: pointer; }

        /* éŸ³æ•ˆé¢æ¿ & éŒ„éŸ³ */
        .tools-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 20px;
            overflow-y: auto;
        }
        .soundboard {
            background: var(--panel-color);
            padding: 15px;
            border-radius: 8px;
        }
        /* æ–°å¢ï¼šBGM é¢æ¿æ¨£å¼ */
        .bgm-panel {
            background: #252525;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #444;
        }
        .sb-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-top: 10px;
        }
        .sb-btn {
            background: #444;
            color: #fff;
            padding: 15px;
            font-size: 0.9rem;
        }
        .sb-btn:active { background: var(--accent-color); color: #000; transform: scale(0.95); }
        
        .recorder-panel {
            background: var(--panel-color);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }
        .rec-status {
            font-size: 1.5rem;
            font-family: monospace;
            color: var(--danger-color);
            margin: 10px 0;
        }
        .toggle-group {
            display: flex;
            align-items: center;
            gap: 10px;
            background: #333;
            padding: 5px 10px;
            border-radius: 20px;
            font-size: 0.8rem;
            width: fit-content;
            margin-bottom: 10px;
        }
        .toggle-btn {
            background: #444;
            border: 1px solid #555;
            padding: 5px 15px;
            color: #aaa;
            font-size: 0.8rem;
        }
        .toggle-btn.active {
            background: var(--success-color);
            color: #000;
            border-color: var(--success-color);
            box-shadow: 0 0 10px rgba(46, 213, 115, 0.3);
        }

        /* æç¤º */
        .warning {
            color: var(--warn-color);
            font-size: 0.8rem;
            margin-top: 5px;
        }
        
        /* éš±è—çš„ Audio å…ƒç´  */
        audio { display: none; }
    </style>
</head>
<body>

    <!-- ç™»å…¥ç•«é¢ -->
    <div id="login-screen">
        <div class="card">
            <h2>é€²å…¥æ„è­˜éŒ„éŸ³å®¤</h2>
            <input type="text" id="nickname" placeholder="è¼¸å…¥ä½ çš„ä»£è™Ÿ (Nickname)" maxlength="10">
            <input type="text" id="roomId" placeholder="æˆ¿è™Ÿ (Room ID)" value="room1">
            <button class="btn-primary" onclick="joinRoom()">å»ºç«‹ / åŠ å…¥æˆ¿é–“</button>
            <div class="warning">âš ï¸ å»ºè­°é…æˆ´è€³æ©Ÿä»¥é¿å…å›æˆ (Echo)</div>
            <div id="debug-msg" style="margin-top:10px; font-size: 0.7rem; color: #888;"></div>
        </div>
    </div>

    <!-- ä¸»ç¨‹å¼ç•«é¢ -->
    <div id="app-screen">
        <header>
            <div>
                <span id="display-room" style="font-weight:bold; color:var(--accent-color)">Room: ???</span>
                <span style="margin: 0 10px">|</span>
                <span id="display-nick">Me: ???</span>
            </div>
            <div id="connection-status" style="font-size:0.8rem; color:#888;">å°šæœªé€£ç·š</div>
        </header>

        <div class="main-container">
            <!-- å·¦å´ï¼šæˆå“¡åˆ—è¡¨ -->
            <div class="member-panel" id="member-list">
                <!-- å‹•æ…‹ç”Ÿæˆçš„æˆå“¡å¡ç‰‡ -->
            </div>

            <!-- å³å´ï¼šå·¥å…· (éŸ³æ•ˆ + éŒ„éŸ³) -->
            <div class="tools-panel">
                
                <!-- BGM é¢æ¿ (æ–°å¢åŠŸèƒ½) -->
                <div class="bgm-panel">
                    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
                        <h3 style="margin:0; font-size:1rem; color:#aaa;">Background Music</h3>
                        <button id="bgm-toggle" class="toggle-btn" onclick="toggleBGM()">OFF</button>
                    </div>
                    <div style="font-size:0.8rem; color:#666; margin-bottom:10px;">
                        æ¨¡å¼: <span style="color:var(--accent-color)">è³½åšé¾å…‹æ°›åœ (Cyberpunk Drone)</span>
                    </div>
                    <div class="controls-row">
                        <span>BGM éŸ³é‡</span>
                        <input type="range" id="bgm-volume" min="0" max="100" value="30">
                    </div>
                </div>

                <!-- éŸ³æ•ˆæ¿ -->
                <div class="soundboard">
                    <div style="display:flex; justify-content:space-between; align-items:center;">
                        <h3>Soundboard</h3>
                        <div class="toggle-group">
                            <label><input type="radio" name="sb-mode" value="local" checked> ç§å¯†è©¦è½</label>
                            <label><input type="radio" name="sb-mode" value="broadcast"> å»£æ’­å…¨å ´</label>
                        </div>
                    </div>
                    <div>
                        <label>éŸ³æ•ˆéŸ³é‡: <span id="sb-vol-val">80%</span></label>
                        <input type="range" id="sb-volume" min="0" max="150" value="80">
                    </div>
                    <div class="sb-grid">
                        <button class="sb-btn" onclick="playEffect('applause')">ğŸ‘ æŒè²</button>
                        <button class="sb-btn" onclick="playEffect('laugh')">ğŸ˜‚ ç¬‘è²</button>
                        <button class="sb-btn" onclick="playEffect('drum')">ğŸ¥ é¼“è²</button>
                        <button class="sb-btn" onclick="playEffect('beep')">ğŸ¤– Beep</button>
                        <button class="sb-btn" onclick="playEffect('boom')">ğŸ’¥ çˆ†ç‚¸</button>
                        <button class="sb-btn" onclick="playEffect('whoosh')">ğŸ’¨ å’»~</button>
                    </div>
                </div>

                <!-- éŒ„éŸ³å€ -->
                <div class="recorder-panel">
                    <h3>æ··éŸ³éŒ„è£½</h3>
                    <div style="font-size: 0.8rem; color:#aaa;">éŒ„è£½ç¯„åœï¼šä½ çš„éº¥å…‹é¢¨ + éšŠå‹è²éŸ³ + éŸ³æ•ˆ + BGM</div>
                    <div id="rec-timer" class="rec-status">00:00</div>
                    <button id="btn-record-toggle" class="btn-record" onclick="toggleRecording()">é–‹å§‹éŒ„éŸ³</button>
                    <div id="download-area" style="margin-top:10px;"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- è…³æœ¬é‚è¼¯ -->
    <script>
        // ================= çµ„æ…‹èˆ‡å…¨åŸŸè®Šæ•¸ =================
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const host = window.location.host; 
        const SIGNALING_URL = `${protocol}//${host}`;
        
        document.getElementById('debug-msg').innerText = `é€£ç·šç›®æ¨™: ${SIGNALING_URL}`;
        console.log("WebSocket URL:", SIGNALING_URL);

        let ws;
        let myId = null;
        let myNickname = "";
        let roomId = "";
        
        // Web Audio Context
        let audioCtx;
        let micSourceNode;      
        let micGainNode;        
        let soundboardGainNode; 
        
        // æ–°å¢ï¼šBGM ç›¸é—œç¯€é»
        let bgmOscillators = []; // å„²å­˜ BGM çš„ç™¼è²å–®å…ƒ
        let bgmGainNode;         // BGM éŸ³é‡æ§åˆ¶
        let isBgmPlaying = false;

        // è·¯ç”±ç¯€é» (Destinations)
        let recordDestNode;     
        let peerDestNode;       
        
        // ç‹€æ…‹
        const peers = {}; 
        let localStream = null;
        let mediaRecorder = null;
        let recordedChunks = [];
        let isRecording = false;
        let recordingStartTime = 0;
        let recordInterval = null;
        let recordingMimeType = ""; // å„²å­˜ç•¶å‰ä½¿ç”¨çš„éŒ„éŸ³æ ¼å¼

        const sfxConfig = {
            'applause': { type: 'noise', duration: 1.5, decay: true }, 
            'laugh': { type: 'sawtooth', freq: [400, 600, 400, 600], duration: 0.5 },
            'drum': { type: 'sine', freq: 100, endFreq: 50, duration: 0.1 },
            'beep': { type: 'square', freq: 880, duration: 0.1 },
            'boom': { type: 'sawtooth', freq: 100, endFreq: 10, duration: 0.8 },
            'whoosh': { type: 'noise', duration: 0.5, fade: true }
        };

        const rtcConfig = {
            iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
        };

        // ================= 1. åˆå§‹åŒ–èˆ‡éŸ³è¨Šè·¯ç”±å»ºç½® =================
        
        async function joinRoom() {
            const nickInput = document.getElementById('nickname');
            const roomInput = document.getElementById('roomId');
            
            if (!nickInput.value || !roomInput.value) {
                alert("è«‹è¼¸å…¥ä»£è™Ÿèˆ‡æˆ¿è™Ÿ");
                return;
            }

            myNickname = nickInput.value;
            roomId = roomInput.value;

            try {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
                setupAudioGraph();

                document.getElementById('login-screen').style.display = 'none';
                document.getElementById('app-screen').style.display = 'flex';
                document.getElementById('display-room').textContent = `Room: ${roomId}`;
                document.getElementById('display-nick').textContent = `Me: ${myNickname}`;

                connectSignaling();
                updateMemberList();

            } catch (err) {
                console.error(err);
                alert("ç„¡æ³•å­˜å–éº¥å…‹é¢¨æˆ–ç™¼ç”ŸéŒ¯èª¤: " + err.message);
            }
        }

        function setupAudioGraph() {
            // A. å»ºç«‹ç¯€é»
            micSourceNode = audioCtx.createMediaStreamSource(localStream);
            micGainNode = audioCtx.createGain(); 
            
            soundboardGainNode = audioCtx.createGain();
            soundboardGainNode.gain.value = 0.8;

            // æ–°å¢ï¼šBGM ç¸½å¢ç›Šç¯€é»
            bgmGainNode = audioCtx.createGain();
            bgmGainNode.gain.value = 0.3; // é è¨­ 30%

            // B. å»ºç«‹ Destinations
            recordDestNode = audioCtx.createMediaStreamDestination();
            peerDestNode = audioCtx.createMediaStreamDestination();

            // C. é€£æ¥ç·šè·¯
            
            // 1. éº¥å…‹é¢¨ -> Peer & Record
            micSourceNode.connect(micGainNode);
            micGainNode.connect(peerDestNode); 
            micGainNode.connect(recordDestNode);
            
            // 2. éŸ³æ•ˆ -> è‡ªå·±è½ & éŒ„éŸ³
            soundboardGainNode.connect(audioCtx.destination);
            soundboardGainNode.connect(recordDestNode);
            
            // 3. BGM -> æ‰€æœ‰äººè½ (Broadcast) & éŒ„éŸ³ & è‡ªå·±è½
            // BGM é è¨­å°±æ˜¯å»£æ’­çµ¦æ‰€æœ‰äººçš„
            bgmGainNode.connect(audioCtx.destination); // è‡ªå·±è½
            bgmGainNode.connect(peerDestNode);         // åˆ¥äººè½
            bgmGainNode.connect(recordDestNode);       // éŒ„éŸ³
        }

        // ================= æ–°å¢ï¼šBGM åŠŸèƒ½é‚è¼¯ =================

        function toggleBGM() {
            const btn = document.getElementById('bgm-toggle');
            
            if (!isBgmPlaying) {
                // é–‹å§‹æ’­æ”¾ (ç”Ÿæˆ Drone éŸ³æ•ˆ)
                startDroneSound();
                isBgmPlaying = true;
                btn.textContent = "ON";
                btn.classList.add('active');
            } else {
                // åœæ­¢æ’­æ”¾
                stopDroneSound();
                isBgmPlaying = false;
                btn.textContent = "OFF";
                btn.classList.remove('active');
            }
        }

        document.getElementById('bgm-volume').addEventListener('input', (e) => {
            if(bgmGainNode) {
                bgmGainNode.gain.value = e.target.value / 100;
            }
        });

        // ä½¿ç”¨ Oscillator ç”Ÿæˆä½é »æ°›åœéŸ³ (Cyberpunk Drone)
        // é€™æ¨£å°±ä¸éœ€è¦è¼‰å…¥å¤–éƒ¨ mp3 æª”æ¡ˆï¼Œå®Œå…¨é ç¨‹å¼ç¢¼ç”Ÿæˆ
        function startDroneSound() {
            const t = audioCtx.currentTime;
            
            // åŸºç¤ä½é » (Bass)
            const osc1 = audioCtx.createOscillator();
            osc1.type = 'sawtooth';
            osc1.frequency.value = 55; // A1
            
            // æ¿¾æ³¢å™¨ (è®“è²éŸ³è®ŠæŸ”å’Œï¼Œåƒé è™•çš„å¼•æ“è²)
            const filter = audioCtx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = 400;

            // LFO (è®“è²éŸ³æœ‰èµ·ä¼)
            const lfo = audioCtx.createOscillator();
            lfo.type = 'sine';
            lfo.frequency.value = 0.1; // 10ç§’ä¸€å€‹å¾ªç’°
            const lfoGain = audioCtx.createGain();
            lfoGain.gain.value = 200; // æ¿¾æ³¢å™¨è®ŠåŒ–ç¯„åœ

            // é€£æ¥: LFO -> LFO Gain -> Filter Frequency
            lfo.connect(lfoGain);
            lfoGain.connect(filter.frequency);

            // ç¨å¾®é«˜ä¸€é»çš„å’Œè²
            const osc2 = audioCtx.createOscillator();
            osc2.type = 'sine';
            osc2.frequency.value = 58; // ç¨å¾®èµ°éŸ³ï¼Œè£½é€ ã€Œæ‹é »(Beating)ã€æ•ˆæœ

            // é€£æ¥ç·šè·¯
            osc1.connect(filter);
            filter.connect(bgmGainNode);
            osc2.connect(bgmGainNode); // Sineæ³¢æ¯”è¼ƒä¹¾æ·¨ï¼Œç›´æ¥é€£

            // å•Ÿå‹•
            osc1.start(t);
            osc2.start(t);
            lfo.start(t);

            // å„²å­˜åƒç…§ä»¥ä¾¿åœæ­¢
            bgmOscillators = [osc1, osc2, lfo];
        }

        function stopDroneSound() {
            const t = audioCtx.currentTime;
            bgmOscillators.forEach(osc => {
                try {
                    // åŠ ä¸Šæ·¡å‡ºæ•ˆæœé¿å…çˆ†éŸ³
                    // é€™è£¡ç°¡å–®è™•ç†ç›´æ¥åœæ­¢ï¼Œå¯¦éš›æ‡‰ç”¨å¯åŠ  Gain æ·¡å‡º
                    osc.stop(t);
                } catch(e) {}
            });
            bgmOscillators = [];
        }

        // ================= 2. WebSocket Signaling (ä¸è®Š) =================

        function connectSignaling() {
            try { ws = new WebSocket(SIGNALING_URL); } 
            catch (e) { alert("WebSocket URL éŒ¯èª¤: " + e.message); return; }

            ws.onopen = () => {
                console.log("WS Connected");
                document.getElementById('connection-status').textContent = "ä¼ºæœå™¨å·²é€£ç·š";
                document.getElementById('connection-status').style.color = "var(--success-color)";
                sendSignal({ type: 'join', roomId: roomId, nickname: myNickname });
            };
            ws.onmessage = async (event) => {
                const data = JSON.parse(event.data);
                handleSignalingData(data);
            };
            ws.onclose = (e) => {
                document.getElementById('connection-status').textContent = "ä¼ºæœå™¨æ–·ç·š";
                document.getElementById('connection-status').style.color = "red";
            };
            ws.onerror = (e) => { console.error("WS Error:", e); };
        }

        async function handleSignalingData(data) {
            switch (data.type) {
                case 'room-info':
                    data.members.forEach(member => {
                        if (member.id !== myId) createPeerConnection(member.id, member.nickname, true);
                    });
                    break;
                case 'user-joined':
                    addSystemLog(`${data.nickname} åŠ å…¥äº†æˆ¿é–“`);
                    break;
                case 'user-left':
                    removePeer(data.id);
                    addSystemLog(`æˆå“¡å·²é›¢é–‹`);
                    break;
                case 'signal':
                    const peerId = data.from;
                    if (!peers[peerId]) await createPeerConnection(peerId, "Unknown", false);
                    const pc = peers[peerId].conn;
                    if (data.desc) {
                        await pc.setRemoteDescription(new RTCSessionDescription(data.desc));
                        if (data.desc.type === 'offer') {
                            const answer = await pc.createAnswer();
                            await pc.setLocalDescription(answer);
                            sendSignal({ type: 'signal', to: peerId, desc: answer });
                        }
                    } else if (data.candidate) {
                        try { await pc.addIceCandidate(new RTCIceCandidate(data.candidate)); } 
                        catch (e) { console.error("ICE Error", e); }
                    }
                    break;
                case 'welcome': myId = data.id; break;
            }
        }

        function sendSignal(msg) { if(ws && ws.readyState === WebSocket.OPEN) ws.send(JSON.stringify(msg)); }

        // ================= 3. WebRTC Peer Connection (ä¸è®Š) =================

        async function createPeerConnection(targetId, nickname, isInitiator) {
            if (peers[targetId]) return; 
            const pc = new RTCPeerConnection(rtcConfig);
            addPeerUI(targetId, nickname);
            
            // åŠ å…¥éŸ³è»Œ (å« BGM)
            peerDestNode.stream.getTracks().forEach(track => pc.addTrack(track, peerDestNode.stream));

            pc.ontrack = (event) => handleRemoteStream(targetId, event.streams[0]);
            pc.onicecandidate = (event) => {
                if (event.candidate) sendSignal({ type: 'signal', to: targetId, candidate: event.candidate });
            };
            pc.onconnectionstatechange = () => {
                updatePeerStatusUI(targetId, pc.connectionState);
                if (pc.connectionState === 'disconnected' || pc.connectionState === 'failed') removePeer(targetId);
            };

            peers[targetId] = { conn: pc, nickname: nickname };
            if (isInitiator) {
                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);
                sendSignal({ type: 'signal', to: targetId, desc: offer });
            }
        }

        function handleRemoteStream(peerId, stream) {
            const remoteSource = audioCtx.createMediaStreamSource(stream);
            const remoteGain = audioCtx.createGain(); 
            remoteGain.connect(audioCtx.destination);
            remoteGain.connect(recordDestNode);
            if (peers[peerId]) {
                peers[peerId].gainNode = remoteGain;
                remoteSource.connect(remoteGain);
            }
            const audioElem = new Audio();
            audioElem.srcObject = stream;
            audioElem.play().catch(e => console.log("Auto-play prevented", e));
        }

        function removePeer(id) {
            if (peers[id]) {
                peers[id].conn.close();
                const el = document.getElementById(`peer-${id}`);
                if (el) el.remove();
                delete peers[id];
            }
        }

        // ================= 4. UI é‚è¼¯ (ä¸è®Š) =================

        function addPeerUI(id, nickname) {
            const container = document.getElementById('member-list');
            const div = document.createElement('div');
            div.id = `peer-${id}`;
            div.className = 'member-card';
            div.innerHTML = `
                <div class="member-header">
                    <span>${nickname}</span>
                    <div><span class="status-dot connecting" id="status-${id}"></span></div>
                </div>
                <div class="controls-row">
                    <span>éŸ³é‡</span>
                    <input type="range" min="0" max="150" value="100" oninput="setPeerVolume('${id}', this.value)">
                </div>
                <div style="text-align:right; font-size:0.7rem; color:#666;">ID: ${id.substr(0,4)}</div>
            `;
            container.appendChild(div);
        }

        function updatePeerStatusUI(id, state) {
            const dot = document.getElementById(`status-${id}`);
            if (dot) dot.className = `status-dot ${state === 'connected' ? 'connected' : ''}`;
        }

        function setPeerVolume(id, val) {
            if (peers[id] && peers[id].gainNode) peers[id].gainNode.gain.value = val / 100;
        }

        function updateMemberList() {}
        function addSystemLog(msg) { console.log(`[System] ${msg}`); }

        // ================= 5. éŸ³æ•ˆæ¿ (ä¸è®Š) =================

        document.getElementById('sb-volume').addEventListener('input', (e) => {
            const val = e.target.value;
            document.getElementById('sb-vol-val').textContent = val + '%';
            if (soundboardGainNode) soundboardGainNode.gain.value = val / 100;
        });

        function playEffect(name) {
            if (!audioCtx) return;
            const mode = document.querySelector('input[name="sb-mode"]:checked').value;
            const config = sfxConfig[name];
            
            const t = audioCtx.currentTime;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            
            gain.connect(soundboardGainNode);

            // ç‰¹æ®Šè·¯ç”±: è‹¥å»£æ’­æ¨¡å¼ï¼Œéœ€é¡å¤–é€£åˆ° peerDestNode (å› ç‚º soundboardGainNode é è¨­åªé€£æœ¬åœ°+éŒ„éŸ³)
            // ç­‰ç­‰... åœ¨ setupAudioGraph è£¡ soundboardGainNode åªé€£åˆ° destination å’Œ recordDestNode
            // æ‰€ä»¥å¦‚æœè¦å»£æ’­ï¼Œé€™è£¡å¿…é ˆå‹•æ…‹é€£æ¥
            if (mode === 'broadcast') {
                gain.connect(peerDestNode); 
            }

            if (config.type === 'noise') {
                const bufferSize = audioCtx.sampleRate * config.duration;
                const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
                const noise = audioCtx.createBufferSource();
                noise.buffer = buffer;
                if (config.decay) {
                    gain.gain.setValueAtTime(1, t);
                    gain.gain.exponentialRampToValueAtTime(0.01, t + config.duration);
                }
                if (config.fade) { 
                    gain.gain.setValueAtTime(0, t);
                    gain.gain.linearRampToValueAtTime(1, t + config.duration/2);
                    gain.gain.linearRampToValueAtTime(0, t + config.duration);
                }
                noise.connect(gain);
                noise.start();
            } else {
                osc.type = config.type;
                if (config.freq) {
                    if (Array.isArray(config.freq)) {
                        osc.frequency.setValueAtTime(config.freq[0], t);
                        osc.frequency.linearRampToValueAtTime(config.freq[1], t + 0.1);
                        osc.frequency.linearRampToValueAtTime(config.freq[2], t + 0.2);
                        osc.frequency.linearRampToValueAtTime(config.freq[3], t + 0.3);
                    } else {
                        osc.frequency.setValueAtTime(config.freq, t);
                        if (config.endFreq) osc.frequency.exponentialRampToValueAtTime(config.endFreq, t + config.duration);
                    }
                }
                gain.gain.setValueAtTime(1, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + config.duration);
                osc.connect(gain);
                osc.start();
                osc.stop(t + config.duration);
            }
        }

        // ================= 6. éŒ„éŸ³åŠŸèƒ½ (ä¿®æ­£æ‰‹æ©Ÿä¸‹è¼‰å•é¡Œ) =================

        function toggleRecording() {
            const btn = document.getElementById('btn-record-toggle');
            if (!isRecording) {
                const mixedStream = recordDestNode.stream;
                
                // 1. è‡ªå‹•åµæ¸¬æ”¯æ´çš„ MIME Type (å„ªå…ˆä½¿ç”¨ mp4 çµ¦ iOS)
                const types = [
                    "audio/mp4", 
                    "audio/webm;codecs=opus", 
                    "audio/webm", 
                    "audio/ogg"
                ];
                recordingMimeType = types.find(t => MediaRecorder.isTypeSupported(t));

                if (!recordingMimeType) {
                    alert("æ‚¨çš„ç€è¦½å™¨ä¸æ”¯æ´éŒ„éŸ³æ ¼å¼ï¼Œè«‹å˜—è©¦ä½¿ç”¨ Chrome, Firefox æˆ– Safari æœ€æ–°ç‰ˆ");
                    return;
                }

                try { 
                    mediaRecorder = new MediaRecorder(mixedStream, { mimeType: recordingMimeType }); 
                } 
                catch (e) { alert("éŒ„éŸ³å•Ÿå‹•å¤±æ•—: " + e.message); return; }
                
                recordedChunks = [];
                mediaRecorder.ondataavailable = (e) => { if (e.data.size > 0) recordedChunks.push(e.data); };
                mediaRecorder.onstop = exportRecording;
                mediaRecorder.start();
                
                isRecording = true;
                btn.textContent = "åœæ­¢éŒ„éŸ³";
                btn.classList.add('active'); 
                btn.style.background = "#333";
                recordingStartTime = Date.now();
                recordInterval = setInterval(() => {
                    const diff = Math.floor((Date.now() - recordingStartTime) / 1000);
                    const m = Math.floor(diff / 60).toString().padStart(2, '0');
                    const s = (diff % 60).toString().padStart(2, '0');
                    document.getElementById('rec-timer').textContent = `${m}:${s}`;
                }, 1000);
            } else {
                mediaRecorder.stop();
                isRecording = false;
                btn.textContent = "é–‹å§‹éŒ„éŸ³";
                btn.classList.remove('active');
                btn.style.background = "var(--danger-color)";
                clearInterval(recordInterval);
            }
        }

        function exportRecording() {
            if (recordedChunks.length === 0) return;

            const blob = new Blob(recordedChunks, { type: recordingMimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            
            // æ±ºå®šå‰¯æª”å (è‹¥ Mime åŒ…å« mp4 å‰‡å‰¯æª”åç‚º mp4ï¼Œå¦å‰‡ webm)
            const ext = recordingMimeType.includes('mp4') ? 'mp4' : 'webm';
            const filename = `recording-${timestamp}.${ext}`;
            
            a.style.display = 'block';
            a.href = url;
            a.download = filename;
            a.target = '_blank'; // [é—œéµ] æ‰‹æ©Ÿä¸Šè‹¥ç„¡æ³•ä¸‹è¼‰ï¼Œé–‹å•Ÿæ–°åˆ†é è®“ä½¿ç”¨è€…æ‰‹å‹•å­˜
            
            a.textContent = `ä¸‹è¼‰éŒ„éŸ³ (${(blob.size/1024/1024).toFixed(2)} MB)`;
            a.className = 'btn-primary';
            a.style.marginTop = '10px';
            a.style.textDecoration = 'none';
            a.style.lineHeight = '40px';
            
            // æç¤ºæ–‡å­—
            const tip = document.createElement('div');
            tip.style.fontSize = '0.8rem';
            tip.style.color = '#aaa';
            tip.style.marginTop = '5px';
            tip.textContent = 'è‹¥æ‰‹æ©Ÿç„¡æ³•è‡ªå‹•ä¸‹è¼‰ï¼Œè«‹é•·æŒ‰æŒ‰éˆ•ä¸¦é¸æ“‡ã€Œä¸‹è¼‰é€£çµã€æˆ–ã€Œå„²å­˜æª”æ¡ˆã€';

            const area = document.getElementById('download-area');
            area.innerHTML = '';
            area.appendChild(a);
            area.appendChild(tip);
        }
    </script>
</body>
</html>
<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å…¨ç¶­åº¦å¤šäººéŒ„éŸ³å®¤ (ç©©å®šéŸ³è¨Šç‰ˆ)</title>
    <style>
        :root {
            --bg-color: #1a1a1a;
            --panel-color: #2d2d2d;
            --text-color: #e0e0e0;
            --accent-color: #00d2ff;
            --danger-color: #ff4757;
            --success-color: #2ed573;
            --warn-color: #ff9f43;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }
        /* ç™»å…¥é é¢ */
        #login-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            z-index: 10;
        }
        .card {
            background: var(--panel-color);
            padding: 2rem;
            border-radius: 12px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.3);
            text-align: center;
            width: 300px;
        }
        input {
            width: 100%;
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            border: 1px solid #444;
            background: #333;
            color: white;
            box-sizing: border-box;
        }
        button {
            padding: 10px 20px;
            border-radius: 4px;
            border: none;
            cursor: pointer;
            font-weight: bold;
            transition: 0.2s;
        }
        .btn-primary { background: var(--accent-color); color: #000; }
        .btn-primary:hover { background: #33e0ff; }
        .btn-danger { background: var(--danger-color); color: white; }
        .btn-fix { 
            background: var(--warn-color); 
            color: #000; 
            font-size: 0.8rem; 
            padding: 5px 10px;
            margin-left: 10px;
            border-radius: 20px;
            display: none; /* é è¨­éš±è— */
        }
        .btn-record { background: var(--danger-color); color: white; width: 100%; margin-top: 10px; }
        
        /* ä¸»ä»‹é¢ */
        #app-screen {
            display: none; /* é è¨­éš±è— */
            flex: 1;
            flex-direction: column;
            padding: 20px;
            gap: 20px;
        }
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 10px;
            border-bottom: 1px solid #444;
        }
        
        /* ä½ˆå±€ */
        .main-container {
            display: flex;
            flex: 1;
            gap: 20px;
            overflow: hidden;
        }
        
        /* æˆå“¡åˆ—è¡¨ */
        .member-panel {
            flex: 1;
            background: var(--panel-color);
            border-radius: 8px;
            padding: 15px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .member-card {
            background: #3a3a3a;
            padding: 10px;
            border-radius: 6px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            border-left: 4px solid var(--accent-color);
            transition: border-color 0.3s;
        }
        .member-header {
            display: flex;
            justify-content: space-between;
            font-weight: bold;
        }
        .status-dot {
            height: 8px;
            width: 8px;
            background-color: #777;
            border-radius: 50%;
            display: inline-block;
            margin-right: 5px;
        }
        .connected { background-color: var(--success-color); }
        .unstable { background-color: var(--warn-color); }
        .disconnected { background-color: var(--danger-color); }
        
        .controls-row {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 0.8rem;
        }
        input[type=range] { flex: 1; cursor: pointer; }

        /* éŸ³æ•ˆé¢æ¿ & éŒ„éŸ³ */
        .tools-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 20px;
            overflow-y: auto;
        }
        .soundboard {
            background: var(--panel-color);
            padding: 15px;
            border-radius: 8px;
        }
        /* æ–°å¢ï¼šBGM é¢æ¿æ¨£å¼ */
        .bgm-panel {
            background: #252525;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #444;
        }
        .sb-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-top: 10px;
        }
        .sb-btn {
            background: #444;
            color: #fff;
            padding: 15px;
            font-size: 0.9rem;
        }
        .sb-btn:active { background: var(--accent-color); color: #000; transform: scale(0.95); }
        
        .recorder-panel {
            background: var(--panel-color);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }
        .rec-status {
            font-size: 1.5rem;
            font-family: monospace;
            color: var(--danger-color);
            margin: 10px 0;
        }
        .toggle-group {
            display: flex;
            align-items: center;
            gap: 10px;
            background: #333;
            padding: 5px 10px;
            border-radius: 20px;
            font-size: 0.8rem;
            width: fit-content;
            margin-bottom: 10px;
        }
        .toggle-btn {
            background: #444;
            border: 1px solid #555;
            padding: 5px 15px;
            color: #aaa;
            font-size: 0.8rem;
        }
        .toggle-btn.active {
            background: var(--success-color);
            color: #000;
            border-color: var(--success-color);
            box-shadow: 0 0 10px rgba(46, 213, 115, 0.3);
        }

        /* æç¤º */
        .warning {
            color: var(--warn-color);
            font-size: 0.8rem;
            margin-top: 5px;
        }
        
        /* éš±è—çš„ Audio å…ƒç´  */
        audio { display: none; }
    </style>
</head>
<body>

    <!-- ç™»å…¥ç•«é¢ -->
    <div id="login-screen">
        <div class="card">
            <h2>é€²å…¥æ„è­˜éŒ„éŸ³å®¤</h2>
            <input type="text" id="nickname" placeholder="è¼¸å…¥ä½ çš„ä»£è™Ÿ (Nickname)" maxlength="10">
            <input type="text" id="roomId" placeholder="æˆ¿è™Ÿ (Room ID)" value="room1">
            <button class="btn-primary" onclick="joinRoom()">å»ºç«‹ / åŠ å…¥æˆ¿é–“</button>
            <div class="warning">âš ï¸ å»ºè­°é…æˆ´è€³æ©Ÿä»¥é¿å…å›æˆ (Echo)</div>
            <div id="debug-msg" style="margin-top:10px; font-size: 0.7rem; color: #888;"></div>
        </div>
    </div>

    <!-- ä¸»ç¨‹å¼ç•«é¢ -->
    <div id="app-screen">
        <header>
            <div>
                <span id="display-room" style="font-weight:bold; color:var(--accent-color)">Room: ???</span>
                <span style="margin: 0 10px">|</span>
                <span id="display-nick">Me: ???</span>
                <button id="btn-audio-fix" class="btn-fix" onclick="resumeAudioContext()">ğŸ”Š æ²’è²éŸ³ï¼Ÿé»æˆ‘ä¿®å¾©</button>
            </div>
            <div id="connection-status" style="font-size:0.8rem; color:#888;">å°šæœªé€£ç·š</div>
        </header>

        <div class="main-container">
            <!-- å·¦å´ï¼šæˆå“¡åˆ—è¡¨ -->
            <div class="member-panel" id="member-list">
                <!-- å‹•æ…‹ç”Ÿæˆçš„æˆå“¡å¡ç‰‡ -->
            </div>

            <!-- å³å´ï¼šå·¥å…· (éŸ³æ•ˆ + éŒ„éŸ³) -->
            <div class="tools-panel">
                
                <!-- BGM é¢æ¿ (æ–°å¢åŠŸèƒ½) -->
                <div class="bgm-panel">
                    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
                        <h3 style="margin:0; font-size:1rem; color:#aaa;">Background Music</h3>
                        <button id="bgm-toggle" class="toggle-btn" onclick="toggleBGM()">OFF</button>
                    </div>
                    <div style="font-size:0.8rem; color:#666; margin-bottom:10px;">
                        æ¨¡å¼: <span style="color:var(--accent-color)">è³½åšé¾å…‹æ°›åœ (Cyberpunk Drone)</span>
                    </div>
                    <div class="controls-row">
                        <span>BGM éŸ³é‡</span>
                        <input type="range" id="bgm-volume" min="0" max="100" value="30">
                    </div>
                </div>

                <!-- éŸ³æ•ˆæ¿ -->
                <div class="soundboard">
                    <div style="display:flex; justify-content:space-between; align-items:center;">
                        <h3>Soundboard</h3>
                        <div class="toggle-group">
                            <label><input type="radio" name="sb-mode" value="local" checked> ç§å¯†è©¦è½</label>
                            <label><input type="radio" name="sb-mode" value="broadcast"> å»£æ’­å…¨å ´</label>
                        </div>
                    </div>
                    <div>
                        <label>éŸ³æ•ˆéŸ³é‡: <span id="sb-vol-val">80%</span></label>
                        <input type="range" id="sb-volume" min="0" max="150" value="80">
                    </div>
                    <div class="sb-grid">
                        <button class="sb-btn" onclick="playEffect('applause')">ğŸ‘ æŒè²</button>
                        <button class="sb-btn" onclick="playEffect('laugh')">ğŸ˜‚ ç¬‘è²</button>
                        <button class="sb-btn" onclick="playEffect('drum')">ğŸ¥ é¼“è²</button>
                        <button class="sb-btn" onclick="playEffect('beep')">ğŸ¤– Beep</button>
                        <button class="sb-btn" onclick="playEffect('boom')">ğŸ’¥ çˆ†ç‚¸</button>
                        <button class="sb-btn" onclick="playEffect('whoosh')">ğŸ’¨ å’»~</button>
                    </div>
                </div>

                <!-- éŒ„éŸ³å€ -->
                <div class="recorder-panel">
                    <h3>æ··éŸ³éŒ„è£½</h3>
                    <div style="font-size: 0.8rem; color:#aaa;">éŒ„è£½ç¯„åœï¼šä½ çš„éº¥å…‹é¢¨ + éšŠå‹è²éŸ³ + éŸ³æ•ˆ + BGM</div>
                    <div id="rec-timer" class="rec-status">00:00</div>
                    <button id="btn-record-toggle" class="btn-record" onclick="toggleRecording()">é–‹å§‹éŒ„éŸ³</button>
                    <div id="download-area" style="margin-top:10px;"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- è…³æœ¬é‚è¼¯ -->
    <script>
        // ================= çµ„æ…‹èˆ‡å…¨åŸŸè®Šæ•¸ =================
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const host = window.location.host; 
        const SIGNALING_URL = `${protocol}//${host}`;
        
        document.getElementById('debug-msg').innerText = `é€£ç·šç›®æ¨™: ${SIGNALING_URL}`;
        console.log("WebSocket URL:", SIGNALING_URL);

        let ws;
        let myId = null;
        let myNickname = "";
        let roomId = "";
        
        // Web Audio Context
        let audioCtx;
        let micSourceNode;      
        let micGainNode;        
        let soundboardGainNode; 
        
        let bgmOscillators = []; 
        let bgmGainNode;         
        let isBgmPlaying = false;

        let recordDestNode;     
        let peerDestNode;       
        
        const peers = {}; 
        let localStream = null;
        let mediaRecorder = null;
        let recordedChunks = [];
        let isRecording = false;
        let recordingStartTime = 0;
        let recordInterval = null;
        let recordingMimeType = ""; 

        const sfxConfig = {
            'applause': { type: 'noise', duration: 1.5, decay: true }, 
            'laugh': { type: 'sawtooth', freq: [400, 600, 400, 600], duration: 0.5 },
            'drum': { type: 'sine', freq: 100, endFreq: 50, duration: 0.1 },
            'beep': { type: 'square', freq: 880, duration: 0.1 },
            'boom': { type: 'sawtooth', freq: 100, endFreq: 10, duration: 0.8 },
            'whoosh': { type: 'noise', duration: 0.5, fade: true }
        };

        const rtcConfig = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
                { urls: 'stun:stun2.l.google.com:19302' }
            ]
        };

        // ================= 1. åˆå§‹åŒ–èˆ‡éŸ³è¨Šè·¯ç”±å»ºç½® =================
        
        async function joinRoom() {
            const nickInput = document.getElementById('nickname');
            const roomInput = document.getElementById('roomId');
            
            if (!nickInput.value || !roomInput.value) {
                alert("è«‹è¼¸å…¥ä»£è™Ÿèˆ‡æˆ¿è™Ÿ");
                return;
            }

            myNickname = nickInput.value;
            roomId = roomInput.value;

            try {
                // ä½¿ç”¨ latencyHint å„ªåŒ–å»¶é²
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                audioCtx = new AudioContext({ latencyHint: 'interactive' });
                
                const constraints = {
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true,
                        channelCount: 1 
                    },
                    video: false
                };

                localStream = await navigator.mediaDevices.getUserMedia(constraints);
                setupAudioGraph();

                document.getElementById('login-screen').style.display = 'none';
                document.getElementById('app-screen').style.display = 'flex';
                document.getElementById('display-room').textContent = `Room: ${roomId}`;
                document.getElementById('display-nick').textContent = `Me: ${myNickname}`;
                
                // é¡¯ç¤ºéŸ³è¨Šä¿®å¾©æŒ‰éˆ•
                document.getElementById('btn-audio-fix').style.display = 'inline-block';

                connectSignaling();
                updateMemberList();

            } catch (err) {
                console.error(err);
                alert("ç„¡æ³•å­˜å–éº¥å…‹é¢¨æˆ–ç™¼ç”ŸéŒ¯èª¤: " + err.message);
            }
        }

        // [æ–°å¢] å¼·åˆ¶å–šé†’éŸ³æ•ˆå¼•æ“
        function resumeAudioContext() {
            if (audioCtx && audioCtx.state === 'suspended') {
                audioCtx.resume().then(() => {
                    alert("éŸ³è¨Šå¼•æ“å·²å–šé†’ï¼è«‹ç¢ºèªæ˜¯å¦èƒ½è½åˆ°è²éŸ³ã€‚");
                });
            } else {
                alert("éŸ³è¨Šå¼•æ“é‹ä½œä¸­ã€‚è‹¥ä»ç„¡è²éŸ³ï¼Œè«‹æª¢æŸ¥é›»è…¦éŸ³é‡æˆ–ç¶²è·¯ç‹€æ³ã€‚");
            }
        }

        function setupAudioGraph() {
            micSourceNode = audioCtx.createMediaStreamSource(localStream);
            micGainNode = audioCtx.createGain(); 
            soundboardGainNode = audioCtx.createGain();
            soundboardGainNode.gain.value = 0.8;
            bgmGainNode = audioCtx.createGain();
            bgmGainNode.gain.value = 0.3; 

            recordDestNode = audioCtx.createMediaStreamDestination();
            peerDestNode = audioCtx.createMediaStreamDestination();

            micSourceNode.connect(micGainNode);
            micGainNode.connect(peerDestNode); 
            micGainNode.connect(recordDestNode);
            
            soundboardGainNode.connect(audioCtx.destination);
            soundboardGainNode.connect(recordDestNode);
            
            bgmGainNode.connect(audioCtx.destination);
            bgmGainNode.connect(peerDestNode);         
            bgmGainNode.connect(recordDestNode);       
        }

        // ================= æ–°å¢ï¼šBGM åŠŸèƒ½é‚è¼¯ =================

        function toggleBGM() {
            const btn = document.getElementById('bgm-toggle');
            if (!isBgmPlaying) {
                startDroneSound();
                isBgmPlaying = true;
                btn.textContent = "ON";
                btn.classList.add('active');
            } else {
                stopDroneSound();
                isBgmPlaying = false;
                btn.textContent = "OFF";
                btn.classList.remove('active');
            }
        }

        document.getElementById('bgm-volume').addEventListener('input', (e) => {
            if(bgmGainNode) bgmGainNode.gain.value = e.target.value / 100;
        });

        function startDroneSound() {
            const t = audioCtx.currentTime;
            const osc1 = audioCtx.createOscillator();
            osc1.type = 'sawtooth';
            osc1.frequency.value = 55; 
            const filter = audioCtx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = 400;
            const lfo = audioCtx.createOscillator();
            lfo.type = 'sine';
            lfo.frequency.value = 0.1; 
            const lfoGain = audioCtx.createGain();
            lfoGain.gain.value = 200; 

            lfo.connect(lfoGain);
            lfoGain.connect(filter.frequency);

            const osc2 = audioCtx.createOscillator();
            osc2.type = 'sine';
            osc2.frequency.value = 58; 

            osc1.connect(filter);
            filter.connect(bgmGainNode);
            osc2.connect(bgmGainNode); 

            osc1.start(t);
            osc2.start(t);
            lfo.start(t);

            bgmOscillators = [osc1, osc2, lfo];
        }

        function stopDroneSound() {
            const t = audioCtx.currentTime;
            bgmOscillators.forEach(osc => { try { osc.stop(t); } catch(e) {} });
            bgmOscillators = [];
        }

        // ================= 2. WebSocket Signaling =================

        function connectSignaling() {
            try { ws = new WebSocket(SIGNALING_URL); } 
            catch (e) { alert("WebSocket URL éŒ¯èª¤: " + e.message); return; }

            ws.onopen = () => {
                document.getElementById('connection-status').textContent = "ä¼ºæœå™¨å·²é€£ç·š";
                document.getElementById('connection-status').style.color = "var(--success-color)";
                sendSignal({ type: 'join', roomId: roomId, nickname: myNickname });
            };
            ws.onmessage = async (event) => {
                const data = JSON.parse(event.data);
                handleSignalingData(data);
            };
            ws.onclose = (e) => {
                document.getElementById('connection-status').textContent = "ä¼ºæœå™¨æ–·ç·š";
                document.getElementById('connection-status').style.color = "red";
            };
            ws.onerror = (e) => { console.error("WS Error:", e); };
        }

        async function handleSignalingData(data) {
            switch (data.type) {
                case 'room-info':
                    data.members.forEach(member => {
                        if (member.id !== myId) createPeerConnection(member.id, member.nickname, true);
                    });
                    break;
                case 'user-joined':
                    addSystemLog(`${data.nickname} åŠ å…¥äº†æˆ¿é–“`);
                    break;
                case 'user-left':
                    removePeer(data.id);
                    addSystemLog(`æˆå“¡å·²é›¢é–‹`);
                    break;
                case 'signal':
                    const peerId = data.from;
                    if (!peers[peerId]) await createPeerConnection(peerId, "Unknown", false);
                    const pc = peers[peerId].conn;
                    if (data.desc) {
                        await pc.setRemoteDescription(new RTCSessionDescription(data.desc));
                        if (data.desc.type === 'offer') {
                            const answer = await pc.createAnswer();
                            await pc.setLocalDescription(answer);
                            sendSignal({ type: 'signal', to: peerId, desc: answer });
                        }
                    } else if (data.candidate) {
                        try { await pc.addIceCandidate(new RTCIceCandidate(data.candidate)); } 
                        catch (e) { console.error("ICE Error", e); }
                    }
                    break;
                case 'welcome': myId = data.id; break;
            }
        }

        function sendSignal(msg) { if(ws && ws.readyState === WebSocket.OPEN) ws.send(JSON.stringify(msg)); }

        // ================= 3. WebRTC Peer Connection (å«é‡è¦ä¿®å¾©) =================

        async function createPeerConnection(targetId, nickname, isInitiator) {
            if (peers[targetId]) return; 
            const pc = new RTCPeerConnection(rtcConfig);
            addPeerUI(targetId, nickname);
            
            peerDestNode.stream.getTracks().forEach(track => pc.addTrack(track, peerDestNode.stream));

            // [é—œéµ] æ¥æ”¶é ç«¯ä¸²æµ
            pc.ontrack = (event) => handleRemoteStream(targetId, event.streams[0]);
            
            pc.onicecandidate = (event) => {
                if (event.candidate) sendSignal({ type: 'signal', to: targetId, candidate: event.candidate });
            };
            
            pc.onconnectionstatechange = () => {
                updatePeerStatusUI(targetId, pc.connectionState);
                if (pc.connectionState === 'disconnected' || pc.connectionState === 'failed') {
                    console.warn(`Peer ${targetId} connection unstable: ${pc.connectionState}`);
                }
            };
            
            pc.oniceconnectionstatechange = () => {
                updatePeerStatusUI(targetId, pc.iceConnectionState);
            };

            peers[targetId] = { conn: pc, nickname: nickname };
            if (isInitiator) {
                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);
                sendSignal({ type: 'signal', to: targetId, desc: offer });
            }
        }

        // [é—œéµä¿®å¾©] è™•ç†é ç«¯è²éŸ³
        function handleRemoteStream(peerId, stream) {
            // 1. Web Audio è·¯å¾‘ (ç”¨æ–¼éŒ„éŸ³ + ç›£è½)
            const remoteSource = audioCtx.createMediaStreamSource(stream);
            const remoteGain = audioCtx.createGain(); 
            
            remoteGain.connect(audioCtx.destination); // è¼¸å‡ºåˆ°å–‡å­ (è½)
            remoteGain.connect(recordDestNode);       // è¼¸å‡ºåˆ°éŒ„éŸ³ (éŒ„)
            
            if (peers[peerId]) {
                peers[peerId].gainNode = remoteGain;
                remoteSource.connect(remoteGain);
            }

            // 2. HTML Audio å…ƒç´ è·¯å¾‘ (ç”¨æ–¼ç¶­æŒé€£ç·šæ´»æ€§ï¼Œä½†è¨­ç‚ºéœéŸ³é¿å…é›™é‡è²éŸ³)
            // é€™æ˜¯è§£æ±ºã€Œæ–·æ–·çºŒçºŒã€èˆ‡ã€Œæ©Ÿå™¨äººéŸ³ã€çš„é—œéµ
            const audioElem = new Audio();
            audioElem.srcObject = stream;
            audioElem.muted = true;    // [é‡è¦] éœéŸ³ï¼é¿å…å’Œ Web Audio é‡ç–Šç”¢ç”Ÿ Phasing
            audioElem.autoplay = true; 
            audioElem.playsInline = true;
            
            // å¼·åˆ¶æ›è¼‰åˆ° DOM (éš±è—)ï¼Œé˜²æ­¢ Chrome ç‚ºäº†çœé›»æš«åœå®ƒ
            audioElem.style.display = 'none';
            document.body.appendChild(audioElem);
            
            // å˜—è©¦æ’­æ”¾ä»¥å•Ÿå‹•ä¸²æµè§£ç¢¼
            audioElem.play().catch(e => console.log("Stream auto-play prevented (Background)", e));
            
            // å­˜èµ·ä¾†ä»¥ä¾¿é›¢é–‹æ™‚ç§»é™¤
            peers[peerId].audioElem = audioElem;
        }

        function removePeer(id) {
            if (peers[id]) {
                peers[id].conn.close();
                // ç§»é™¤ DOM ä¸Šçš„ audio å…ƒç´ 
                if (peers[id].audioElem) {
                    peers[id].audioElem.remove();
                }
                const el = document.getElementById(`peer-${id}`);
                if (el) el.remove();
                delete peers[id];
            }
        }

        // ================= 4. UI é‚è¼¯ =================

        function addPeerUI(id, nickname) {
            const container = document.getElementById('member-list');
            const div = document.createElement('div');
            div.id = `peer-${id}`;
            div.className = 'member-card';
            div.innerHTML = `
                <div class="member-header">
                    <span>${nickname}</span>
                    <div><span class="status-dot connecting" id="status-${id}" title="é€£ç·šä¸­..."></span></div>
                </div>
                <div class="controls-row">
                    <span>éŸ³é‡</span>
                    <input type="range" min="0" max="150" value="100" oninput="setPeerVolume('${id}', this.value)">
                </div>
                <div style="text-align:right; font-size:0.7rem; color:#666;">ID: ${id.substr(0,4)}</div>
            `;
            container.appendChild(div);
        }

        function updatePeerStatusUI(id, state) {
            const dot = document.getElementById(`status-${id}`);
            const card = document.getElementById(`peer-${id}`);
            if (!dot) return;

            dot.className = 'status-dot';
            
            if (state === 'connected' || state === 'completed') {
                dot.classList.add('connected');
                dot.title = "é€£ç·šç©©å®š";
                card.style.borderColor = "var(--success-color)";
            } else if (state === 'disconnected' || state === 'failed' || state === 'closed') {
                dot.classList.add('disconnected');
                dot.title = "é€£ç·šä¸­æ–·";
                card.style.borderColor = "var(--danger-color)";
            } else {
                dot.classList.add('unstable'); 
                dot.title = "é€£ç·šå»ºç«‹ä¸­æˆ–ä¸ç©©å®š...";
                card.style.borderColor = "#777";
            }
        }

        function setPeerVolume(id, val) {
            if (peers[id] && peers[id].gainNode) peers[id].gainNode.gain.value = val / 100;
        }

        function updateMemberList() {}
        function addSystemLog(msg) { console.log(`[System] ${msg}`); }

        // ================= 5. éŸ³æ•ˆæ¿ =================

        document.getElementById('sb-volume').addEventListener('input', (e) => {
            const val = e.target.value;
            document.getElementById('sb-vol-val').textContent = val + '%';
            if (soundboardGainNode) soundboardGainNode.gain.value = val / 100;
        });

        function playEffect(name) {
            if (!audioCtx) return;
            const mode = document.querySelector('input[name="sb-mode"]:checked').value;
            const config = sfxConfig[name];
            
            const t = audioCtx.currentTime;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            
            gain.connect(soundboardGainNode);

            if (mode === 'broadcast') {
                gain.connect(peerDestNode); 
            }

            if (config.type === 'noise') {
                const bufferSize = audioCtx.sampleRate * config.duration;
                const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
                const noise = audioCtx.createBufferSource();
                noise.buffer = buffer;
                if (config.decay) {
                    gain.gain.setValueAtTime(1, t);
                    gain.gain.exponentialRampToValueAtTime(0.01, t + config.duration);
                }
                if (config.fade) { 
                    gain.gain.setValueAtTime(0, t);
                    gain.gain.linearRampToValueAtTime(1, t + config.duration/2);
                    gain.gain.linearRampToValueAtTime(0, t + config.duration);
                }
                noise.connect(gain);
                noise.start();
            } else {
                osc.type = config.type;
                if (config.freq) {
                    if (Array.isArray(config.freq)) {
                        osc.frequency.setValueAtTime(config.freq[0], t);
                        osc.frequency.linearRampToValueAtTime(config.freq[1], t + 0.1);
                        osc.frequency.linearRampToValueAtTime(config.freq[2], t + 0.2);
                        osc.frequency.linearRampToValueAtTime(config.freq[3], t + 0.3);
                    } else {
                        osc.frequency.setValueAtTime(config.freq, t);
                        if (config.endFreq) osc.frequency.exponentialRampToValueAtTime(config.endFreq, t + config.duration);
                    }
                }
                gain.gain.setValueAtTime(1, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + config.duration);
                osc.connect(gain);
                osc.start();
                osc.stop(t + config.duration);
            }
        }

        // ================= 6. éŒ„éŸ³åŠŸèƒ½ =================

        function toggleRecording() {
            const btn = document.getElementById('btn-record-toggle');
            if (!isRecording) {
                const mixedStream = recordDestNode.stream;
                
                const types = ["audio/mp4", "audio/webm;codecs=opus", "audio/webm", "audio/ogg"];
                recordingMimeType = types.find(t => MediaRecorder.isTypeSupported(t));

                if (!recordingMimeType) {
                    alert("æ‚¨çš„ç€è¦½å™¨ä¸æ”¯æ´éŒ„éŸ³æ ¼å¼ï¼Œè«‹å˜—è©¦ä½¿ç”¨ Chrome, Firefox æˆ– Safari æœ€æ–°ç‰ˆ");
                    return;
                }

                try { 
                    mediaRecorder = new MediaRecorder(mixedStream, { mimeType: recordingMimeType }); 
                } 
                catch (e) { alert("éŒ„éŸ³å•Ÿå‹•å¤±æ•—: " + e.message); return; }
                
                recordedChunks = [];
                mediaRecorder.ondataavailable = (e) => { if (e.data.size > 0) recordedChunks.push(e.data); };
                mediaRecorder.onstop = exportRecording;
                mediaRecorder.start();
                
                isRecording = true;
                btn.textContent = "åœæ­¢éŒ„éŸ³";
                btn.classList.add('active'); 
                btn.style.background = "#333";
                recordingStartTime = Date.now();
                recordInterval = setInterval(() => {
                    const diff = Math.floor((Date.now() - recordingStartTime) / 1000);
                    const m = Math.floor(diff / 60).toString().padStart(2, '0');
                    const s = (diff % 60).toString().padStart(2, '0');
                    document.getElementById('rec-timer').textContent = `${m}:${s}`;
                }, 1000);
            } else {
                mediaRecorder.stop();
                isRecording = false;
                btn.textContent = "é–‹å§‹éŒ„éŸ³";
                btn.classList.remove('active');
                btn.style.background = "var(--danger-color)";
                clearInterval(recordInterval);
            }
        }

        function exportRecording() {
            if (recordedChunks.length === 0) return;

            const blob = new Blob(recordedChunks, { type: recordingMimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const ext = recordingMimeType.includes('mp4') ? 'mp4' : 'webm';
            const filename = `recording-${timestamp}.${ext}`;
            
            a.style.display = 'block';
            a.href = url;
            a.download = filename;
            a.target = '_blank'; 
            
            a.textContent = `ä¸‹è¼‰éŒ„éŸ³ (${(blob.size/1024/1024).toFixed(2)} MB)`;
            a.className = 'btn-primary';
            a.style.marginTop = '10px';
            a.style.textDecoration = 'none';
            a.style.lineHeight = '40px';
            
            const tip = document.createElement('div');
            tip.style.fontSize = '0.8rem';
            tip.style.color = '#aaa';
            tip.style.marginTop = '5px';
            tip.textContent = 'è‹¥æ‰‹æ©Ÿç„¡æ³•è‡ªå‹•ä¸‹è¼‰ï¼Œè«‹é•·æŒ‰æŒ‰éˆ•ä¸¦é¸æ“‡ã€Œä¸‹è¼‰é€£çµã€æˆ–ã€Œå„²å­˜æª”æ¡ˆã€';

            const area = document.getElementById('download-area');
            area.innerHTML = '';
            area.appendChild(a);
            area.appendChild(tip);
        }
    </script>
</body>
</html>